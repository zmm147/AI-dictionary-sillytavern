# 静默时自动备份方案

## 方案概述

在用户不活跃（静默）时自动备份数据到服务器，避免频繁备份影响性能，同时确保数据及时保存。

## 实现方式

### 1. 用户活动检测

监听用户交互事件，判断用户是否活跃：

```javascript
class IdleDetector {
    constructor(idleTimeout = 30000) { // 默认30秒
        this.idleTimeout = idleTimeout;
        this.idleTimer = null;
        this.isIdle = false;
        this.needsBackup = false;
        this.callbacks = {
            onIdle: [],
            onActive: []
        };

        this.init();
    }

    init() {
        // 监听用户活动事件
        const events = [
            'mousedown', 'mousemove', 'keypress',
            'scroll', 'touchstart', 'click'
        ];

        events.forEach(event => {
            document.addEventListener(event, () => this.resetTimer(), true);
        });

        // 监听标签页可见性变化
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // 标签页隐藏时立即触发备份
                this.triggerIdle();
            } else {
                // 标签页显示时重置
                this.resetTimer();
            }
        });

        // 监听浏览器关闭
        window.addEventListener('beforeunload', () => {
            if (this.needsBackup) {
                // 同步备份（阻塞式）
                this.performSyncBackup();
            }
        });

        // 启动定时器
        this.resetTimer();
    }

    resetTimer() {
        // 用户活跃，重置定时器
        if (this.isIdle) {
            this.isIdle = false;
            this.triggerActive();
        }

        clearTimeout(this.idleTimer);
        this.idleTimer = setTimeout(() => {
            this.triggerIdle();
        }, this.idleTimeout);
    }

    triggerIdle() {
        if (!this.isIdle) {
            this.isIdle = true;
            console.log('[IdleDetector] User is idle');

            // 触发静默回调
            this.callbacks.onIdle.forEach(cb => cb());

            // 如果需要备份，执行备份
            if (this.needsBackup) {
                this.performBackup();
            }
        }
    }

    triggerActive() {
        console.log('[IdleDetector] User is active');
        this.callbacks.onActive.forEach(cb => cb());
    }

    markNeedsBackup() {
        this.needsBackup = true;
        console.log('[IdleDetector] Marked for backup');
    }

    async performBackup() {
        if (!this.needsBackup) return;

        console.log('[IdleDetector] Performing idle backup...');

        try {
            // 调用备份函数
            await window.aiDictionary?.backupToServer?.();
            this.needsBackup = false;
            console.log('[IdleDetector] Backup completed');
        } catch (error) {
            console.error('[IdleDetector] Backup failed:', error);
            // 备份失败，保持标记，下次再试
        }
    }

    performSyncBackup() {
        // 同步备份（用于浏览器关闭时）
        console.log('[IdleDetector] Performing sync backup...');

        try {
            // 使用 sendBeacon 或同步 XHR
            const data = window.aiDictionary?.getBackupData?.();
            if (data) {
                // 使用 sendBeacon（推荐）
                const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                navigator.sendBeacon('/api/ai-dictionary/backup', blob);
            }
        } catch (error) {
            console.error('[IdleDetector] Sync backup failed:', error);
        }
    }

    onIdle(callback) {
        this.callbacks.onIdle.push(callback);
    }

    onActive(callback) {
        this.callbacks.onActive.push(callback);
    }
}
```

### 2. 集成到扩展

在扩展初始化时创建静默检测器：

```javascript
// 在 index.js 中
let idleDetector;

async function initExtension() {
    // ... 现有初始化代码

    // 创建静默检测器
    idleDetector = new IdleDetector(30000); // 30秒静默时间

    // 监听静默事件
    idleDetector.onIdle(() => {
        console.log('[AI Dictionary] User idle, checking for backup...');
    });

    idleDetector.onActive(() => {
        console.log('[AI Dictionary] User active');
    });

    // 暴露到全局
    window.aiDictionary.idleDetector = idleDetector;
}
```

### 3. 数据修改时标记需要备份

在所有修改数据的地方调用标记函数：

```javascript
// 在 database.js 中
async function addWord(word) {
    // 添加单词到数据库
    await db.add('wordHistory', word);

    // 更新时间戳
    await updateTimestamp();

    // 标记需要备份
    window.aiDictionary?.idleDetector?.markNeedsBackup();
}

async function updateReviewQueue(queue) {
    // 更新复习队列
    await db.put('reviewQueue', queue);

    // 更新时间戳
    await updateTimestamp();

    // 标记需要备份
    window.aiDictionary?.idleDetector?.markNeedsBackup();
}

// 在所有修改数据的函数中添加类似的调用
```

### 4. 备份策略配置

在设置中添加配置选项：

```javascript
// 默认设置
const defaultSettings = {
    backup: {
        autoBackup: true,              // 启用自动备份
        idleTimeout: 30000,            // 静默时间（毫秒）
        backupOnTabHidden: true,       // 标签页隐藏时立即备份
        backupOnBeforeUnload: true,    // 浏览器关闭时备份
        maxBackupInterval: 300000,     // 最大备份间隔（5分钟）
    }
};
```

### 5. 定期备份（兜底机制）

即使用户一直活跃，也应该定期备份：

```javascript
class IdleDetector {
    constructor(idleTimeout = 30000, maxBackupInterval = 300000) {
        this.idleTimeout = idleTimeout;
        this.maxBackupInterval = maxBackupInterval;
        this.lastBackupTime = Date.now();

        // 启动定期检查
        this.startPeriodicCheck();
    }

    startPeriodicCheck() {
        setInterval(() => {
            const timeSinceLastBackup = Date.now() - this.lastBackupTime;

            if (this.needsBackup && timeSinceLastBackup > this.maxBackupInterval) {
                console.log('[IdleDetector] Max interval reached, forcing backup');
                this.performBackup();
            }
        }, 60000); // 每分钟检查一次
    }

    async performBackup() {
        if (!this.needsBackup) return;

        try {
            await window.aiDictionary?.backupToServer?.();
            this.needsBackup = false;
            this.lastBackupTime = Date.now();
        } catch (error) {
            console.error('[IdleDetector] Backup failed:', error);
        }
    }
}
```

## 优化方案

### 1. 防抖（Debounce）

避免频繁标记备份：

```javascript
class IdleDetector {
    constructor() {
        this.markBackupDebounced = this.debounce(() => {
            this.needsBackup = true;
        }, 1000); // 1秒内的多次修改只标记一次
    }

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    markNeedsBackup() {
        this.markBackupDebounced();
    }
}
```

### 2. 备份队列

避免同时触发多个备份：

```javascript
class BackupQueue {
    constructor() {
        this.isBackingUp = false;
        this.pendingBackup = false;
    }

    async enqueue(backupFunc) {
        if (this.isBackingUp) {
            // 正在备份，标记待处理
            this.pendingBackup = true;
            return;
        }

        this.isBackingUp = true;

        try {
            await backupFunc();
        } finally {
            this.isBackingUp = false;

            // 如果有待处理的备份，执行
            if (this.pendingBackup) {
                this.pendingBackup = false;
                this.enqueue(backupFunc);
            }
        }
    }
}
```

### 3. 备份失败重试

```javascript
class IdleDetector {
    async performBackup(retries = 3) {
        if (!this.needsBackup) return;

        for (let i = 0; i < retries; i++) {
            try {
                await window.aiDictionary?.backupToServer?.();
                this.needsBackup = false;
                this.lastBackupTime = Date.now();
                console.log('[IdleDetector] Backup completed');
                return;
            } catch (error) {
                console.error(`[IdleDetector] Backup failed (attempt ${i + 1}/${retries}):`, error);

                if (i < retries - 1) {
                    // 等待后重试
                    await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
                }
            }
        }

        // 所有重试都失败，保持标记
        console.error('[IdleDetector] All backup attempts failed');
    }
}
```

## 使用 Page Visibility API

更精确地检测标签页状态：

```javascript
class IdleDetector {
    init() {
        // ... 其他初始化代码

        // 使用 Page Visibility API
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                console.log('[IdleDetector] Page hidden, triggering backup');
                this.triggerIdle();
            } else if (document.visibilityState === 'visible') {
                console.log('[IdleDetector] Page visible');
                this.resetTimer();
            }
        });
    }
}
```

## 使用 Idle Detection API（实验性）

浏览器原生的静默检测API：

```javascript
async function useIdleDetectionAPI() {
    if ('IdleDetector' in window) {
        try {
            const idleDetector = new IdleDetector();

            idleDetector.addEventListener('change', () => {
                const userState = idleDetector.userState;
                const screenState = idleDetector.screenState;

                console.log(`User: ${userState}, Screen: ${screenState}`);

                if (userState === 'idle') {
                    // 用户静默，执行备份
                    window.aiDictionary?.idleDetector?.performBackup();
                }
            });

            await idleDetector.start({
                threshold: 30000, // 30秒
            });
        } catch (error) {
            console.error('Idle Detection API not available:', error);
            // 降级到手动检测
        }
    }
}
```

## 设置界面

在设置页面添加配置选项：

```html
<div class="backup-settings">
    <h3>自动备份设置</h3>

    <label class="checkbox_label">
        <input type="checkbox" id="auto-backup-enabled" checked>
        <span>启用自动备份</span>
    </label>

    <div class="setting-field">
        <label>静默时间（秒）</label>
        <input type="number" id="idle-timeout" value="30" min="10" max="300">
        <small>用户停止操作多久后触发备份</small>
    </div>

    <div class="setting-field">
        <label>最大备份间隔（分钟）</label>
        <input type="number" id="max-backup-interval" value="5" min="1" max="60">
        <small>即使用户一直活跃，也会定期备份</small>
    </div>

    <label class="checkbox_label">
        <input type="checkbox" id="backup-on-tab-hidden" checked>
        <span>切换标签页时立即备份</span>
    </label>

    <label class="checkbox_label">
        <input type="checkbox" id="backup-on-close" checked>
        <span>关闭浏览器时备份</span>
    </label>

    <div class="backup-status">
        <p>上次备份：<span id="last-backup-time">从未</span></p>
        <p>待备份更改：<span id="pending-changes">0</span></p>
    </div>

    <button id="manual-backup-btn" class="menu_button">
        <i class="fa-solid fa-cloud-arrow-up"></i>
        立即备份
    </button>
</div>
```

## 优点

1. **不影响用户体验** - 在用户不活跃时备份
2. **减少服务器压力** - 避免频繁请求
3. **数据安全** - 多种触发机制确保数据保存
4. **灵活配置** - 用户可以自定义备份策略

## 注意事项

1. **浏览器关闭时的备份**
   - `beforeunload` 事件中只能执行同步操作
   - 使用 `navigator.sendBeacon()` 发送数据
   - 或者使用同步 XHR（不推荐）

2. **移动端兼容性**
   - 移动浏览器可能会暂停后台标签页
   - 需要在 `visibilitychange` 时立即备份

3. **网络状态**
   - 检测网络连接状态
   - 离线时缓存备份请求

4. **性能考虑**
   - 大数据量时备份可能耗时
   - 考虑增量备份或压缩

## 完整示例

```javascript
// idle-backup.js
export class IdleBackupManager {
    constructor(options = {}) {
        this.idleTimeout = options.idleTimeout || 30000;
        this.maxBackupInterval = options.maxBackupInterval || 300000;
        this.enabled = options.enabled !== false;

        this.idleTimer = null;
        this.isIdle = false;
        this.needsBackup = false;
        this.lastBackupTime = Date.now();
        this.isBackingUp = false;

        if (this.enabled) {
            this.init();
        }
    }

    init() {
        this.setupEventListeners();
        this.startPeriodicCheck();
        this.resetTimer();
    }

    setupEventListeners() {
        const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];
        events.forEach(event => {
            document.addEventListener(event, () => this.onUserActivity(), true);
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this.onPageHidden();
            } else {
                this.onPageVisible();
            }
        });

        window.addEventListener('beforeunload', () => {
            this.onBeforeUnload();
        });
    }

    onUserActivity() {
        if (this.isIdle) {
            this.isIdle = false;
            console.log('[IdleBackup] User active');
        }
        this.resetTimer();
    }

    onPageHidden() {
        console.log('[IdleBackup] Page hidden, triggering backup');
        this.triggerBackup();
    }

    onPageVisible() {
        console.log('[IdleBackup] Page visible');
        this.resetTimer();
    }

    onBeforeUnload() {
        if (this.needsBackup) {
            this.performSyncBackup();
        }
    }

    resetTimer() {
        clearTimeout(this.idleTimer);
        this.idleTimer = setTimeout(() => {
            this.onIdle();
        }, this.idleTimeout);
    }

    onIdle() {
        if (!this.isIdle) {
            this.isIdle = true;
            console.log('[IdleBackup] User idle');
            this.triggerBackup();
        }
    }

    markNeedsBackup() {
        this.needsBackup = true;
    }

    async triggerBackup() {
        if (!this.needsBackup || this.isBackingUp) return;

        this.isBackingUp = true;

        try {
            await this.performBackup();
            this.needsBackup = false;
            this.lastBackupTime = Date.now();
            console.log('[IdleBackup] Backup completed');
        } catch (error) {
            console.error('[IdleBackup] Backup failed:', error);
        } finally {
            this.isBackingUp = false;
        }
    }

    async performBackup() {
        // 调用实际的备份函数
        if (window.aiDictionary?.backupToServer) {
            await window.aiDictionary.backupToServer();
        }
    }

    performSyncBackup() {
        // 同步备份（用于 beforeunload）
        try {
            const data = window.aiDictionary?.getBackupData?.();
            if (data && navigator.sendBeacon) {
                const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                navigator.sendBeacon('/api/ai-dictionary/backup', blob);
            }
        } catch (error) {
            console.error('[IdleBackup] Sync backup failed:', error);
        }
    }

    startPeriodicCheck() {
        setInterval(() => {
            const timeSinceLastBackup = Date.now() - this.lastBackupTime;

            if (this.needsBackup && timeSinceLastBackup > this.maxBackupInterval) {
                console.log('[IdleBackup] Max interval reached, forcing backup');
                this.triggerBackup();
            }
        }, 60000);
    }

    enable() {
        this.enabled = true;
        this.init();
    }

    disable() {
        this.enabled = false;
        clearTimeout(this.idleTimer);
    }
}
```

## 总结

静默备份方案可以很好地解决频繁备份的问题，配合时间戳机制，可以实现：

1. **智能备份** - 只在需要时备份
2. **不影响体验** - 在用户不活跃时执行
3. **数据安全** - 多种触发机制保证数据不丢失
4. **灵活配置** - 用户可以自定义策略

建议实现优先级：
1. 基础静默检测 + 标记备份
2. 标签页隐藏时立即备份
3. 定期备份（兜底）
4. 浏览器关闭时备份
5. 高级功能（重试、队列等）
